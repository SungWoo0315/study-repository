# 2021년 6월 24일 [31일차]

## # 오전수업
----
### `09:30~`

<135> 번부터 ~  

테이블 구조 파악하는것이 중요함.  

### <135> 월별로 [입사월], [인원수]를 검색하면? <조건>입사월 오름차순 유지하십쇼

```SQL  
select
	to_char(hire_date, 'MM')||'월' "입사월"
	,count(*)||'명' "입사인원수"
from
	employee
group by
	to_char(hire_date, 'MM')||'월'
order by
	"입사월" asc;
```

`count` 에서 `*`가 들어가면 행의 개수를 구함. `컬럼`이 들어가면 null값을 빼고 개수를 구함.


### <136> employee 테이블에서 직급순서대로 정렬하여 직급별로 [직급], [직급평균연봉], [인원수]를 검색하면? (높은직급이 먼저 나와야함. 직급이 같으면 먼저태어난 직원이 먼저나오기)

직급`별`, 그룹을 지어서..  => `group by`  

```SQL  
select
	jikup                           "직급"
	,round(avg(salary),1)           "직급평균연봉"
	,count(*)||'명'   "인원수"
from
	employee
--where -- 굳이 나와야 한다면 where 절 위치는 여기이다.  

group by
	jikup
--having   --인원수 5명 이상만 보고 싶을때 having을 써서 골라낸다. group by 에서 행을 골라내기 위해서 사용.  
    --count(*)>=5
order by
    decode( jikup,'사장', 1,'부장', 2,'과장', 3,'대리', 4,'주임', 5, 6) asc;
--order by decode( "직급",'사장', 1,'부장', 2,'과장', 3,'대리', 4,'주임', 5, 6) asc; --이것도가능

```
`group by` 안쓰고 `select` 안을 주석처리하고 각각 실행해보면 행열이 맞지 않다. 이럴 경우  

중복제거하고 그룹지어주는 => `group by` 쓴다.  

`order by` 에서 `1 asc;` 해주면 `ㄱ,ㄴ` 순으로 정리해버린다.  
`decode`를 사용하여서 각 직급을 숫자로 바꾸어서 정렬.  

`order by`는 맨 밑에 나와야한다. `group by`위에 나오면 오류가 난다.  -<입>  

`order by`에서 쓸수 있는것. => 리얼컬럼, 순서번호, 알리아스  


### <137> 부서별 [부서번호], [부서명], [직원수], [직원이관리하는고객수]를 검색하면?

```SQL  
-------------------------------------------------------------
답1
-------------------------------------------------------------
select
	d.dep_no                        "부서번호"
	,d.dep_name                     "부서명"
	,count(distinct(e.emp_no))      "직원수"   -- 중복된 직원수를 제거해야 한다.
	,count(c.emp_no)                "직원이관리하는고객수"
from
	employee e, dept d, customer c
where --컬럼을 붙이는 조건.
	d.dep_no = e.dep_no(+)
	and
	e.emp_no = c.emp_no(+)
group by
	d.dep_no, d.dep_name;

-------------------------------------------------------------
답2
-------------------------------------------------------------
	select
		d.dep_no as "부서번호"
		,d.dep_name "부서명"
		,(select count(*)||'명' from employee e where e.dep_no = d.dep_no) "부서직원수"
		,(select count(*)||'명' from employee e, customer c where e.dep_no = d.dep_no and e.emp_no = c.emp_no) "담당 고객 수"
	from
		dept d;  
```
직원이 없는 부서가 있을 수 있음. 부서별로 통계를 낸다면 소속된 부서가 없는 직원이 나와야 한다.  `outer join` 필요.  

그룹지을 대상을 `group by`에 단일컬럼을 넣어준다.  

고객을 담당하는 직원 수 면 `distinct`써야 하지만,   
한명의 직원이 여러명의 고객을 담당할 수 있기 때문에, "직원이 관리하는 고객수"는 `distinct`쓰면 안된다.  





















----
### `10:30~`








----
### `11:30~`








----
### `12:30~`








----
### `13:20~`

  - 점심시간.

---
---

## # 오후수업

---
### `14:30~`










---
### `15:30~`









----
### `16:30~`








----
### `17:30~`








----
### `18:30~`
