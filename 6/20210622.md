# 2021년 6월 22일 [29일차]

## # 오전수업
----
### `09:30~`

<복습>

join을 하는 목적. 서로다른 테이블의 컬럼을 횡으로 붙여서 유저에게 보기쉬운 데이터 제공. 유저가 보기 편하게 하기 위해서.    

공부하면서 이것을 쓰면 어떤 효과 이득을 얻는지 생각하면서 공부하기.
```  
ex) 자바에서는 상속, 멤버공유로 자원낭비를 막는다.  
자바에서 컬렉션을 쓰는 이유는? 쓰면 얻는 이득은? 다량의 데이터를 관리하기위해 사용.    

배열의 단점때문에 컬렉션이 나왔다.
배열의 단점 : 저장될 개수를 모르면 사용하기 힘들다. 미리 개수를 정해주어야 하기 때문. 실상황에서는 얼마만큼의 DB가 들어올지 모르기 때문에 쓸 수 없다.

동일한 유형의 데이터를 저장하는것이 좋다.
배열은 같은형의 데이터를 저장. 컬렉션은 다양한형의 데이터를 저장할수 있지만 장점이 아니다. 어느위치에서 형변환해서 꺼내야하는지 어렵기 때문.
```

- `inner join` :  

- `outer join` :  

- `self join` : 하나의 테이블을 두개 이상으로 보고 join  

- `cross join` : where절이 없다. 거의 쓰이지 않음.  


`오라클조인` :  
`ANSI조인` : 이해하긴 편하지만 테이블이 3개이상 되면 코딩이 늘어나게 된다.      
```
정의, 부연설명, 예시 순서로 설명하기
```
`join` :
`union` : 두개이상을 종으로 붙이는것.    

#

### <103> 고객번호, 고객명, 고객주민번호 출력하라. 단 40살 이상인 담당직원이 담당한 고객이어야한다.

조인같지 않는 조인문제.  

<주의>**코딩 상 분명히 조인이지만 출력되는 컬럼은 한개의 테이블에서 나오는 컬럼이다. 위 코딩은 조인이 출력 목적이 아닌, 조건목적으로 사용된것이다.**

+추가문제 : 10부서 또는 30번 부서 직원이 담당하는 고객을 검색하면?

```SQL  
select
  c.cus_no
  ,c.cus_name
from
  customer c, employee e
where
c.emp_no = e.emp_no
and
(e.dep_no = 10 or e.dep_no = 30)
-- e.dep_no in (10,30)  --in 으로도 사용 가능.


and or 사용 시 () 사용 주의.
보여주는건 고객정보지만 행을 골라내는 조건은 employee테이블에 있기 때문에 join 을 쓸수 밖에 없다.  
```

서브쿼리 할 수 있는건 조인으로 할 수 있고,  
조인으로 할 수 있는건 서브쿼리로 할 수 있다.  

서브쿼리가 심플한 느낌.  


### <104> 고객번호, 고객명, 담당직원번호, 담당직원명, 담당직원소속부서명, 담당직원연봉등급, 담당직원직속상관명, 담당직원직속상관직급, 직속상관연봉등급 출력하라. 단, 고객은 다 나와야하고 null은 없음 으로 표시.

```SQL  
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,nvl(to_char(e1.emp_no),'없음')	"담당직원번호"
	,nvl(e1.emp_name,'없음') "담당직원명"
	,nvl(d.dep_name,'없음') "담당직원소속부서명"
	,nvl(to_char(s1.sal_grade_no),'없음') "담당직원연봉등급"
	,nvl(e2.emp_name,'없음') "담당직원직속상관명"
	,nvl(e2.jikup,'없음') "담당직원직속상관직급"
	,nvl(to_char(s2.sal_grade_no),'없음') "직속상관연봉등급"
	--,nvl(c.cus_name||'','없음') -> to_char 대신 쓰는 방법.  
from
	customer c, employee e1, dept d, salary_grade s1, employee e2, salary_grade s2
where
	c.emp_no = e1.emp_no(+)
	and
	e1.dep_no = d.dep_no(+)
	and
	e1.mgr_emp_no = e2.emp_no(+)
	and
	--s1.min_salary(+) <= e1.salary and s1.max_salary(+) >= e1.salary
	e1.salary between s1.min_salary(+) and s1.max_salary(+)
	and
	--s2.min_salary(+) <= e2.salary and s2.max_salary(+) >= e2.salary
	e2.salary between s2.min_salary(+) and s2.max_salary(+)
order by
c.cus_no asc;


고객은 다나와야 함으로 `outer join`
경우에 따라서는 `inner join`결과와 `outer join`결과가 같을 수가 있다. 모든 조건이 맞아서 다 나오게 되면 결과가 같아질수 있다.  
```

```SQL  
ANSI조인
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,nvl(to_char(e1.emp_no),'없음')	"담당직원번호"
	,nvl(e1.emp_name,'없음') "담당직원명"
	,nvl(d.dep_name,'없음') "담당직원소속부서명"
	,nvl(to_char(s1.sal_grade_no),'없음') "담당직원연봉등급"
	,nvl(e2.emp_name,'없음') "담당직원직속상관명"
	,nvl(e2.jikup,'없음') "담당직원직속상관직급"
	,nvl(to_char(s2.sal_grade_no),'없음') "직속상관연봉등급"
	--,nvl(c.cus_name||'','없음') -> to_char 대신 쓰는 방법.  

from ((((customer c left outer join employee e1 on c.emp_no = e1.emp_no)
lef outer join dept d on e1.dep_no = d.dep_no)
lef outer join salary_grade s1 on e.salary between s1.min_salary and s1.max_salary)
lef outer join employee e2 on e1.mgr_emp_no = e2.emp_no)
lef outer join salary_grade s2 on e2.salary between s2.min_salary and s2.max_salary
order by c.cus_no asc;
```
<ANSI조인 다시 해보기>

----
### `10:30~`

### <105> 직원명, 직원전화번호와 고객명, 고객전화번호를 종으로 붙여 출력하라.

`union` : 유니온을 쓰면 중복된것은 제거.

`union all` : 중복된것도 나오게 함

```SQL  
select emp_name||'직원', phone from employee
union
select cus_name||'고객', tel_num from customer
----------------------------------------
union all 중복행을 제거한다.
```


### <106> 직원명, 직원전화번호와 고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복허락

```SQL  
select emp_name, phone from employee
union all
select cus_name, tel_num from customer
----------------------------------------
union all 중복행을 허락한다.
```

**<주의>**  
종으로 붙이는 컬럼끼리의 자료형이 같아야 한다.  
```SQL  
select emp_name||'직원', phone from employee
union
select cus_no||'고객', tel_num from customer
----------------------------------------
union all 중복행을 제거한다.
```
> 자료형이 달라서 안됨.  











----
### `11:30~`








----
### `12:30~`








----
### `13:20~`

  - 점심시간.

---
---

## # 오후수업

---
### `14:30~`










---
### `15:30~`









----
### `16:30~`








----
### `17:30~`








----
### `18:30~`
