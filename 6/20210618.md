# 2021년 6월 18일 [27일차]

## # 오전수업
----
### `09:30~`

### <57> employee 테이블에서 수요일에 태어난 직원을 검색하라 (새로추가)  

행을 골라내기위한 조건식  

select 뒤의 컬럼은 출력하기위해...  
where 뒤의 컬럼은 비교하기위해...  

```SQL  
select * from employee
where
to_char(
		to_date(
			case substr(jumin_num,7,1) when '1' then '19'
			when '2' then '19' else '20' end||substr(jumin_num,1,6)
			, 'YYYYMMDD'
		)
		, 'DY'
		, 'NLS_DATE_LANGUAGE = Korean'
	) = '수';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'D'
)
= '4';
```

```
`D` 만쓰면 요일대신 숫자로 나온다.  
일요일 = 1
월요일 = 2
화요일 = 3
수요일 = 4 ....

요일에 부등호 부여하여 적용할때 사용할 수 있다.
```


### <58> employee 테이블에서 70년대생 남자 직원을 검색하라 (새로추가)    

년대생을 구하는것.  

주민등록에서  
첫글자가 7인 동시에 7번째가 1인것을 구하는것.  

```SQL  
  select * from employee
  where
    substr(jumin_num,1,1) = '7'
    and
    substr(jumin_num,7,1) = '1';
```

```SQL  
select * from employee
where
  substr(jumin_num,1,1) = '7'
  and
  (substr(jumin_num,7,1) = '1' or substr(jumin_num,7,1) = '3');


<주의>
and or 묶어주지 않고 동시에 쓰면 and 부터 연산된다.  
원하는 결과를 얻을 수 없음.
'3'을 쓰는 남자까지 얻고 싶으면 `()` 로 묶어서 연산순서를 정해줘야 한다.  
```

### <59> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라  

```SQL  
select * from employee
where
	(substr(jumin_num,1,1) = '6'
	or
	substr(jumin_num,1,1) = '7'
	)
	and
	(substr(jumin_num,7,1) = '1'
	or
	substr(jumin_num,7,1) = '3'
	);
```

`()` 를 해주지 않으면 결과 값이 완전히 달라진다.  

----
### `10:30~`

### <60> employee 테이블에서 오래 근무한 직원이 먼저 나오게 검색하면?  

근무일수 = 오늘날짜 - 입사한날짜


```SQL  
select * from employee
order by
	to_number(sysdate-hire_date)
desc;

---

select * from employee
order by
	(sysdate-hire_date)
desc;
```

### <61> employee 테이블에서 직원번호, 직원명, 근무일수, 근무개월수, 입사후 5개월후 날짜(년-월-일), 입사한달의마지막날짜(년-월-일), 입사한날짜에서돌아오는일요일날짜(년-월-일) 검색하면? 단, 근무일수는 소수 2자리에서 반올림 하삼

`months_between` : 날짜사이 `개월수`로 리턴한다.        
`add_months` : 날짜에 개월수 더한 날의 날짜를 리턴.     
`last_day` : 날짜가 속한 달의 마지막 날짜를 리턴.    
`next_day` : 요일은 수치로 들어간다.  날짜를 리턴.  

요일은 숫자로 1~7 사이. (일요일 1 월요일 2 ...)  

```SQL  
select
	emp_no                              "직원번호"
	,emp_name                           "직원명"
	,sysdate-hire_date                  "근무일수"
	,months_between(sysdate,hire_date)  "근무개월수"
from
employee;
```

```SQL  
select
	emp_no                                         "직원번호"
	,emp_name                                      "직원명"
	,round(sysdate-hire_date, 1)                   "근무일수"
	,months_between(sysdate,hire_date)             "근무개월수"
	,to_char(add_months(hire_date,5), 'YYYY-MM-DD')  "입사후5개월후날짜"
	,to_char(last_day(hire_date), 'YYYY-MM-DD')  "입사한달의마지막날짜"
	,to_char(next_day(hire_date,1), 'YYYY-MM-DD') "입사한날짜에서돌아오는일요일날짜"

from
employee;
```

java  
```java  
Xxx x = new Xxx();

? y = x.abc();

abc메소드 리턴값 자료형 기억이 안날때, Object 넣으면된다.
모든 클래스는 무조건상속받는... -> Object
Object 줘도 에러가 나면.. abc는 리턴값이 없는 void 이다.
```

----
### `11:30~`

날짜관련 정리.  
```
---------------------------------------------
months_between(날짜1, 날짜2) => 날짜1에 날짜2의 차이를 개월수로 리턴하기
---------------------------------------------
add_months(날짜1, 개월수) => 날짜에 개월수 만큼 더한 날의 날짜를 리턴하기
---------------------------------------------
last_day(날짜) => 날짜가 속한 달의 마지막 날짜를 리턴하기
---------------------------------------------
next_day(날짜, 요일정수) => 날짜기준으로 돌아오는 요일의 날짜를 리턴하기
													요일정수는 1~7(1은일 ~ 토)
---------------------------------------------
날짜1 - 날짜2 => 날짜1 과 날짜2 의 차이를 일수로 리턴하기
---------------------------------------------
날짜 + 정수 => 날짜에다 정수만큼의 일수를 더한 만큼의 날의 날짜를 리턴하기
---------------------------------------------
날짜 - 정수 => 날짜에다 정수만큼의 일수를 뺀만큼의 날의 날짜를 리턴하기
```

근무일수, 근무개월수 소수점 컨트롤하는 함수.  


`round(숫자저장컬럼명, 정수)` : 정수는 보여지는 소수 자리수이고 그전 자리수에서 반올림을 한것이다.  
`round(sysdate-hire_date, 1) => 소수 둘째자리에서 반올림한 결과 리턴`  

`trunc(숫자저장컬럼명, 정수)` : 정수는 보여지는 소수 자리수이고 그이후는 모두 버림.  
`trunc(sysdate-hire_date, 1) => 소수 둘째자리 이후는 모두 버리고 리턴`  



```
Tip
시간날때 자기소개서 작성 조금씩 해둘것
```


### <62> employee 테이블에서 직급이 과장인 직원을 검색하면?

```SQL  
select * from employee
where
jikup = '과장';

```

### <63> employee 테이블에서 직급이 과장이 아닌 직원을 검색하면?

```SQL  
select * from employee where jikup != '과장';
select * from employee where jikup <> '과장';

위의 두개는 같은 결과를 리턴하는것임.
```


### <64> employee 테이블에서 부서번호가 10번이고 직급이 과장인 직원을 검색하면?

```SQL  
select * from employee where dep_no = 10 and jikup = '과장';
```

### <65> employee 테이블에서 직급이 과장 또는 부장인 직원을 검색하면? (기)

```SQL  
select * from employee where jikup = '과장' or jikup = '부장';
select * from employee where jikup in('과장', '부장');
select * from employee where jikup = any('과장', '부장');

in 은 `=` 없다.

any 왼쪽의 `=` 조심하자.

위의 세개는 같은 결과를 리턴하는것임.
```

`in` : =과 or 을 간략화 하고 싶을 때.


### <66> employee 테이블에서 10번, 20번 부서 중에 직급이 과장인 직원을 검색하면?


```SQL  
select * from employee where (dep_no = 10 or dep_no = 20) and jikup = '과장';
select * from employee where dep_no in(10, 20) and jikup = '과장';

두의 두 결과는 같은것임.

in은 or가 먼저 연산되어서. `()` 안써도 된다.
```


```
Tip
기사시험. 데이터 통신쪽이 어려울수 있으니 공부 할것.
```

----
### `12:30~`




















----
### `13:20~`

  - 점심시간.

---
---

## # 오후수업

---
### `14:30~`










---
### `15:30~`









----
### `16:30~`








----
### `17:30~`








----
### `18:30~`
