# 2021년 6월 28일 [33일차]

## # 오전수업
----
### `09:30~`

오전 진행 일정 : 인라인뷰(inline view) => jsp  

오후 진행 일정 : 오라클 문제 설명 & 복습.  

#


### <139> [인라인뷰(=Inline view)] 가 뭡니까? `*****`  

`inline view`  

from 절에 나오는 select 를 말한다.  
from 절에는 테이블명이 나온다.  
이 자리에 select 나올 경우 select 결과물을 테이블로 생각하면 된다.    
인라인뷰는 select 결과물을 테이블로 취급하기 때문에 메모리에 부담을 준다.  


from 절 안에 select 가 나온다. 서브쿼리라고 하지 않고 `inline view` 라고 한다.    

사용빈도가 아주 높다.  

----
### `10:30~`

### <140> 연봉 서열대로 직원을 검색하되 1행부터 10행까지만 검색하면?

select 결과물을 웹 브라우져로 보여줄때, 검색 결과를 지정한 개수만큼 끊어서 보여주는것. JSP 관련. => `페이징 처리`  

현업은 게시판소스에서 파생.  

오라클은 자동으로 어떤 테이블이건 간에 모든 select결과물에 rownum컬럼을 붙여 일련번호까지 넣어준다.  

rownum은 정렬한다음에 붙여준것이 아니라, order by 전에 붙여버려서 진행되어서 일련번호가 뒤엉킨다. 원하는 결과를 얻을 수 없음.  

> 인라인뷰 기본 문법

```SQL  
SELECT column_list
FROM (SELECT * FROM table_name) [alias]
WHERE 조건식;
```

```SQL  
select
	*
from
	(select * from employee order by salary desc)
where
	rownum<=10
-- 정답은 맞지만 다른 행 검색 조건에선 틀릴수 있다.
-- rownum이 where절에 들어갈때 rownum 1이 들어가서 true 되는 조건만 나올수 있는데,
-- rownum>=11 에서 1이 포함 안되기 때문에 false.
-- 이런식으로는 행 검색을 할 수 없다.

--정답1.
select
	*
from
(
select
	rownum RNUM, e.*
from
	(select * from employee order by salary desc) e
where
	rownum<=10
)
where
	RNUM>=1

--정답2.
select
	*
from
(
select
	rownum RNUM, e.*
from
	(select * from employee order by salary desc) e
)
where
	RNUM>=1 and RNUM<=10;

-- where rownum<=10 을 안쪽에서 실행하지 않고 바깥쪽 where절에서 RNUM으로 1~10 조건을 주어도 된다. RNUM이 일반 컬럼으로 인식되기 때문. 그렇지만 속도차이가 2배 이상 난다.  
MYSQL 은 limit 로 처리 가능.

--패턴화.
select * from ( select rownum RNUM, 별칭.* from (
	원하는 정렬 select 문
) 별칭 where rownum<=마지막행번호 ) where RNUM>=시작행번호;

-- 추가문제
-- 고객을 나이대로 서열 정리. 6행부터 10행까지.
select * from ( select rownum RNUM, zxcvb.* from (
	select * from customer
	order by
		decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6) asc
) zxcvb where rownum<=10 ) where RNUM>=6;

-- 추가문제
-- <새끼문제> 직원 직급 서열중 2행~5행 까지 검색하면?
-------------------------------------------------------------
select * from ( select rownum RNUM, zxcvb.* from (
	select * from employee
	order by
		decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6) asc
) zxcvb where rownum<=5 ) where RNUM>=2;
```


> 인라인뷰 패턴화.  

```SQL  
--패턴화.
select * from ( select rownum RNUM, 별칭.* from (
	원하는 정렬 select 문
) 별칭 where rownum<=마지막행번호 ) where RNUM>=시작행번호;
```

----
### `11:30~`

### <127>번 문제를 인라인뷰로 풀이.  

```SQL
-- group by
select
  dep_no                "부서번호"
  ,jikup                "직급"
  ,sum(salary)          "급여합"
  ,round(avg(salary),1) "평균급여"
  ,count(*)||'명'       "인원수"
from
  employee
group by
  dep_no, jikup
having
  count(*) >= 3;
------------------------------------------------------------
group by 결과물에서 행을 골라낼 때에는 where 을 쓰지 말고 having 을 사용한다.

-- inline view
select
  *
from
(
select
  dep_no                DEP_NO
  ,jikup                JIKUP
  ,sum(salary)          TOT_SALARY
  ,round(avg(salary),1) AVG_SALARY
  ,count(*)             EMP_CNT
from
  employee
group by
  dep_no, jikup
)
where
  EMP_CNT >= 3
```


### <135>번 문제는 없는 달은 나오지 않는다. 없는 달도 포함하여, 즉 1월~12월 까지 다 나오게 하려면?  

<135>번 입사인원수가 없는달은 안나옴. 인라인뷰를 사용하면 없던달도 표현 가능.   


```SQL  
-- group by, join 으로 푼것.
select
  m.month||'월'                      "입사월"
  ,count(e.emp_name)||'명'           "입사인원수"
from
(
select '01' "MONTH" from dual union
select '02' from dual union
select '03' from dual union
select '04' from dual union
select '05' from dual union
select '06' from dual union
select '07' from dual union
select '08' from dual union
select '09' from dual union
select '10' from dual union
select '11' from dual union
select '12' from dual
) m
,employee e
where
  to_char(e.hire_date(+), 'MM') = m.month
group by
  m.month||'월'
order by
  "입사월";

"MONTH"는 바깥쪽에서 테이블처럼 보고 검색하여야 하므로 영어(대문자)로 명시해주어야 한다.
```

----
### `12:30~`

위 문제는 group by, join 으로 푼것.

상관쿼리로 풀이 추가

```SQL  
--상관쿼리로 풀이 추가
select
	  m.month||'월'                      "입사월"
		,(select count(*) from employee e where to_char(e.hire_date, 'MM')=m.month )    "입사인원수"
from
(
select '01' "MONTH" from dual union
select '02' from dual union
select '03' from dual union
select '04' from dual union
select '05' from dual union
select '06' from dual union
select '07' from dual union
select '08' from dual union
select '09' from dual union
select '10' from dual union
select '11' from dual union
select '12' from dual
) m
```

```SQL  
-- 올바른 풀이는 아니지만 참고. rownum 사용.
select
	  m.month||'월'                      "입사월"
		,(select count(*) from employee e where to_char(e.hire_date, 'MM')=m.month )    "입사인원수"
from
(
  select case when rownum<10 then '0' else '' end||rownum "MONTH" from employee where rownum<=12
) m
```


### <141> 오늘부터 10일 이후 까지 날짜 중에 토요일, 일요일, 월요일을 제외한 날의 개수를 구하면? -inline view

```SQL  
--내가 한것.
select
	count(*) from
(
select to_char(sysdate+1, 'DAY') "D" from dual union
select to_char(sysdate+2, 'DAY') from dual union
select to_char(sysdate+3, 'DAY') from dual union
select to_char(sysdate+4, 'DAY') from dual union
select to_char(sysdate+5, 'DAY') from dual union
select to_char(sysdate+6, 'DAY') from dual union
select to_char(sysdate+7, 'DAY') from dual union
select to_char(sysdate+8, 'DAY') from dual union
select to_char(sysdate+9, 'DAY') from dual union
select to_char(sysdate+10, 'DAY') from dual
) d
where
d.D!='토'
and d.D!='일'
and d.D!='월'


-- 정답
select count(*) from
(
	select sysdate "XDAY" from dual
	union select sysdate+1 from dual
	union select sysdate+2 from dual
	union select sysdate+3 from dual
	union select sysdate+4 from dual
	union select sysdate+5 from dual
	union select sysdate+6 from dual
	union select sysdate+7 from dual
	union select sysdate+8 from dual
	union select sysdate+9 from dual
	union select sysdate+10 from dual
) d
where
	to_char(d.xday, 'dy', 'nls_date_language = korean')!='토'
	and to_char(d.xday, 'dy', 'nls_date_language = korean')!='일'
	and to_char(d.xday, 'dy', 'nls_date_language = korean')!='월'
```











----
### `13:20~`

  - 점심시간.

---
---

## # 오후수업

---
### `14:30~`










---
### `15:30~`









----
### `16:30~`








----
### `17:30~`








----
### `18:30~`
