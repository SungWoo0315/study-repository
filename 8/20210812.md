# 2021년 8월 12일 [64일차]

## # 오전수업
----
### `09:30~`  

<복습>      

어제 마지막에 한 Java `인터페이스`       

개념 복습하기.     

오후에 `인터페이스` 추가 설명.     

#      

`[HttpServletRequest] 객체`를 `request 객체`라고 부르기도 한다.   

클라이언트가 보낸 모든 파라미터명와 파라미터값은 꺼낼때 모두 String형 이다.    
형변환은 꺼낸 다음에.    

```
"파라미터명" = name 값  
"파라미터값" = value 값  

"파라미터명" = 오라클의 테이블 컬럼명
```

- 철자 조심하기.  
  
  `String[] getParameterValues( "파라미터명" )` => `values`, `s` 조심하기.     
  > 체크박스 처럼 다량의 데이터를 가져오는것. select box. multiple 써서 펼쳐놓고 ctrl 키 눌러서 다중선택하면,    
  > name 값은 하나인데 value 값은 여러개 들어올 수 있다.    

#

### # `HttpServletRequest` 객체 메소드   ★★★★★  어제 이어서...


#### # `void setAttribute( "키값문자열", 저장객체 )`   ★★★★★

```
  -------------------------------------
  void setAttribute( "키값문자열", 저장객체 )   ★★★★★ (입)
  -------------------------------------
      [키값문자열]에 [저장객체]를 연결하여 저장한다. HashMap 객체와 동일한 역할을 한다.  
      매개변수로 전달되는 저장객체는 주로 DB 연동 결과물이다.  

      DB 연동이 insert, update, delete 일 경우 [저장객체]는 [정수]이다.  
      DB 연동이 select 일 경우 DB 연동 결과물은 검색 결과에 따라 아래 처럼 다르다.  
          ------------------------------------------------------------------------
          1행 1열 검색된 경우 => DB 연동 결과물은 [정수 또는 실수 또는 String] 이다.    
          1행 n열 검색된 경우 => DB 연동 결과물은 [HashMap 객체] 이다.    
          n행 1열 검색된 경우 => DB 연동 결과물은 [ArrayList, LinkedList, 배열 객체] 이다.    
          n행 m열 검색된 경우 => DB 연동 결과물은 List<Map<String,String>> 이다.    
          ------------------------------------------------------------------------
```

----
### `10:30~`

`ArrayList<HashMap<String,String>>` = `List<Map<String,String>>`  
> 한행의 데이터를 HashMap에 담고, 다량의 HashMap을 ArrayList 에 담는다.    

```
=================================================================================
SQL 구문의 종류             SQL 구문 실행결과(=DB 연동 결과물)를 저장하는 자바 객체 자료형
=================================================================================
insert,update,delete       int
---------------------------------------------------------------------------------
1행 1열 검색 select         int 또는 double 또는 String
---------------------------------------------------------------------------------
1행 n열 검색 select         HashMap 객체   
---------------------------------------------------------------------------------
n행 1열 검색 select         ArrayList 또는 LinkedList 또는 배열 객체
---------------------------------------------------------------------------------
n행 m열 검색 select         List<Map<String,String>> 객체
---------------------------------------------------------------------------------
```
> HashMap, ArrayList, LinkedList, Vector, HashTable => `Collection`

#

```
  -----------------------------------------------------------
  <예> insert 구문의 실행 결과를 setAttribute 메소드로 저장하기
  -----------------------------------------------------------
  insert into dept values(50, '기획부', '서울');
  위 insert 구문에 의해 입력된 행의 개수는 1개 이다.    
  결국, insert 구문을 실행한 결과물은 int 형이다.  
  자바변수 선언하고 insert 구문을 실행한 결과물을 저장하면 아래와 같다.  
  -----------------------------------------------------------
  int deptInsertCnt = 위 insert 구문에 의해 입력된 행의 개수;
  request.setAttribute( "deptInsertCnt", deptInsertCnt );
  request.setAttribute( "deptInsertCnt", new Integer(deptInsertCnt) );
```
> 기본형데이터가 기본형을 관리하는 객체로 전환. `new Integer(deptInsertCnt)`

#

- insert, update, 1행 1열

  ```
    ----------------------------------------------------------------
    <예> insert 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        insert 구문
            insert into dept values(50,'기획부','서울');
        insert 구문의 실행 결과가 저장되는 변수 
            int deptInsertCnt = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "deptInsertCnt", deptInsertCnt );

    ----------------------------------------------------------------
    <예> update 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        update 구문
            update dept set loc='부산' where dep_no=50; 
        update 구문의 실행 결과가 저장되는 변수 
            int deptUpCnt = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "deptUpCnt", deptUpCnt );
    ----------------------------------------------------------------
    <예> 1행 1열 검색 select 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        select 구문  
            select count(*) from employee where salary >= 4000
        select 구문의 실행 결과가 저장되는 변수 
            int empCnt = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "empCnt", empCnt );
    ----------------------------------------------------------------
    <예> 1행 1열 검색 select 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        select 구문  
            select dep_name from dept where dep_no = 40
        select 구문의 실행 결과가 저장되는 변수 
            String depName = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "depName", depName );
    ----------------------------------------------------------------
    <예> 1행 1열 검색 select 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        select 구문  
            select avg(salary) from employee
        select 구문의 실행 결과가 저장되는 변수 
            double avgSalary = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "avgSalary", avgSalary );
  ```
  > 날짜는 문자 취급.  

----
### `11:30~`

`setAttribute( "키값문자열", 저장객체 )` 는 JSP 에서 꺼낼때 사용하기 위해 일단 저장하는것.  

- 1행 n열 

  ```
    ----------------------------------------------------------------
    <예> 1행 n열 검색 select 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        select 구문 
            select emp_no, emp_name, salary from employee where emp_no = 3;
        select 구문의 실행 결과가 저장되는 변수 
            HashMap empMap = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "empMap", empMap );
  ```
  > HashMap 써줘도 되지만 인터페이스를 활용하여 Map 써도 된다. Map 을 더 많이 쓴다.   


- n행 1열 
  ```
    ----------------------------------------------------------------
    <예> n행 1열 검색 select 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        select 구문 
            select emp_name from employee where jikup = '과장';
        select 구문의 실행 결과가 저장되는 변수 
            ArrayList empNames = ~;
            ArrayList empNameList = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "empNames", empNames );
            request.setAttribute( "empNameList", empNameList );
  ```
  > `ArrayList` 일땐, 변수끝에 `List` 써주면 구분하기 쉽다.  


- n행 m열 
  ```
    ----------------------------------------------------------------
    <예> n행 m열 검색 select 구문의 실행 결과를 setAttribute 메소드로 저장하기
    ----------------------------------------------------------------
        select 구문 
            ----------------------------------------------------
            보여줄 컬럼명
                직원번호, 직원명, 소속부서명
            조건
                연봉이 3000 이상인직원
            ----------------------------------------------------
            select 
                e.emp_no, e.emp_name, d.dep_name 
            from 
                employee e, dept d 
            where 
                e.det_no = d.dep_no and e.salary >= 3000;
            ----------------------------------------------------
            > ANSI join
            select e.emp_no, e.emp_name, d.dep_name, e.salary 
            from employee e inner join dept d 
            on e.dep_no = d.dep_no 
            where e.salary >= 3000;
            ----------------------------------------------------
        select 구문의 실행 결과가 저장되는 변수 
            List<Map<String,String>> empList = ~;
        setAttribute 메소드는 호출 코딩
            request.setAttribute( "empList", empList );
  ```
  > 쿼리문 연습 많이 해야 한다.  

#

- ArrayList 와 List 차이.  

  ![ArrayList 와 List 차이](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210812%201214_JSP_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_List_Map_.png)  

  > `ArrayList` 는 `클래스`,       
  > `List` 는 `인터페이스`,      
  > 인터페이스는 객체화 할 수 없다. `객참변수 자료형`으로 사용.      
  > 실제로는 변수에 ArrayList 객체 메위주가 들어 있다.   
  > `List` 인터페이스를 구현한 `ArrayList` 가 객체화 된다.    

  > `HashMap` 과 `Map` 도 같은 이유 이다.  

----
### `12:30~`

- `<<>>` 설명을 위한 자바내용.  `제네릭스`

  ```java
  ArrayList list = new ArrayList();
  list.add("이름1");
  list.add("이름2");
  list.add("이름3");
  list.add( new Integer(kor) );

  String name1 = (String)list.get(0);
  String name2 = (String)list.get(1);
  String name3 = (String)list.get(2);
  Integer kor  = (Integer)list.get(3);
  ```
  > `get()` 메서드 리턴값 => `Object`  

  > 다량의 내용을 저장하기 때문에,   
  > 꺼낼 때는 뭘 꺼내는지 모르기 때문에,   
  > 합당하게 형 변환을 시켜주어야 한다.   

  > 꺼낼때는 형변환을 해주어야 한다.   

  > 위와같이 하면 형변환이 힘들다. 자료가 많아지면 다 기억못하므로.    

  ```Java
  ArrayList list = new ArrayList();
  list.add("이름1");
  list.add("이름2");
  list.add("이름3");

  String name1 = (String)list.get(0);
  String name2 = (String)list.get(1);
  String name3 = (String)list.get(2);
  //------------------------------------
  ArrayList<String> list = new ArrayList<String>();
  list.add("이름1");
  list.add("이름2");
  list.add("이름3");

  String name1 = list.get(0);
  String name2 = list.get(1);
  String name3 = list.get(2);
  //------------------------------------
  //------------------------------------
  //------------------------------------
  HashMap map = new HashMap();
  map.put( "이름", "홍길동" );
  map.put( "주소", "가산동" );
  map.put( "키", new Integer(182) );

  String name = (String)map.get("이름");
  String addr = (String)map.get("주소");
  Integer tall = (integer)map.get("키");
  //------------------------------------
  HashMap<String,String> map = new HashMap<String,String>();
  map.put( "이름", "홍길동" );
  map.put( "주소", "가산동" );

  String name = map.get("이름");
  String addr = map.get("주소");

  ```
  > `제네릭스`를 쓰면 꺼낼 때 형변환을 해주지 않아도 된다.      
  > `제네릭스`를 써서 객체생성을 하면 꺼낼때 형변환 필요 없다.      
  > 특정 유형만 저장하도록 `제네릭스` `<   >` 로 지정.  

  > 위에서는 String 만 저장하도록 했음.    

  > 개발자가 직접 자료형을 설정.    

#

- 배열, HashMap, ArrayList 비교 설명.  

  ![배열, HashMap, ArrayList 비교 설명](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210812%201301_%EB%B0%B0%EC%97%B4_HashMap_ArrayList_.png)  

  > 배열은 저장개수 미리 정해놓고 써야함.  

  > `HashMap` 은 저장순서가 없으므로 `키값`이 필요하다.  

  > 배열의 유일한 장점은. 기본형이 저장 가능하다.
  > 인덱스번호가 있어서 반복문 돌리기 쉽다.    

기본형에는 컬렉션에 저장할수 없다. 방법은?  오후에 설명.  

----
### `13:20~`

  - 점심시간.

---
---

## # 오후수업

---
### `14:30~`

제네릭을 쓰는 이유는 자료형을 규제하기 위함.    

집어넣고 꺼낼때 형변환이 필요 없게 된다.   

#

```
  -------------------------------------
  Object getAttribute( "키값문자열" )   ★★★★ (입)
  -------------------------------------
      setAttribute( "키값문자열", 저장객체 )로 저장된 [저장객체]를 Object 타입으로 리턴한다.                  
      setAttribute( "키값문자열", 저장객체 )로 저장된 [저장객체]가 뭔지 모르는 상태에서 
      getAttribute 로 꺼냈을 때 리턴 자료형을 무엇으로 써야되는지의 문제는 Object 타입으로 해결된다.  
      모든 클래스 최상위 조상은 바로 Object 클래스이기 때문이다.
      <주의> getAttribute( "empList" ) 에서 "empList" 라는 키값이 없을 경우
              null 이 리턴된다. 에러가 발생하지는 않는다.  
```

- Object 클래스 설명. 

  ![Object1](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210812%201509_JSP_Object_1.png)      


  ![Object2](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210812%201509_JSP_Object_2.png)    
  
  > 최상위 클래스
  > 객참변수의 자료형은 부모쪽 클래스형을 써도 된다.  

  > 어떤 자료형이 나올지 모르기 때문에,  
  > 변수의 자료형을 Object 로 해주면 된다.  

---
### `15:30~`

```
  -------------------------------------
  void removeAttribute( "키값문자열" )   
  -------------------------------------
      setAttribute( "키값문자열", 저장객체 )로 저장된 [저장객체]를 삭제한다.     

  -------------------------------------
  HttpSession getSession( )
  -------------------------------------
      HttpSession 객체의 메위주를 리턴한다.  
```
> 객체의 메위주가 필요한 이유는? 메서드를 호출하기 위해서.  

#

```
  -------------------------------------
  Cookie[] getCookies( )
  -------------------------------------
      Cookie 객체가 저장된 배열 객체를 리턴한다.  
      ------------------------------
      Cookie 객체란?
      ------------------------------
          웹브라우저가 웹서버에게 보낸 [요청 메시지] 안에 저장된 쿠키값을 관리하는 객체이다.  
          1개의 쿠키값을 1개의 Cookie 객체가 관리한다.  
```
> 쿠키값들을 관리하는 쿠키객체를 얻을때 사용.     
> `쿠키 객체`가 들어있는 `배열객체` 리턴     
> 리턴값이 배열객체인 경우 복수형 `s` 를 붙이는것이 관용.  

#

```

```


> StringBuffer 는 기존 문자열에 추가 수정 삭제 가능하다.    

> String 객체는 한번소유한 문자열은 추가 수정 삭제가 불가능.  

> `StringBuffer` 실무에선 잘 사용하지 않지만, (입) 입사시험에 나옴.    

> ![String 설명]()  
>    
> String 객체는 문자를 더하면 계속해서 새로운 객체를 생성해서 변수에 대입한다.  
> 메모리 낭비가 심해진다.  


> ![StringBuffer 설명]()    
> 






----
### `16:30~`








----
### `17:30~`








----
### `18:30~`
