# 2021년 9월 16일 [86일차]

## # 오전수업
----
### `09:30~`

<복습>   

공용함수 랜덤.  

#

스프링에서 자바코드는 패턴화 되어 있다.  

의외로 자바스크립트에서 고생한다.    

#

<진도>   

랜덤뽑기 로직 어제 수업 이어서...     

- getRandomData

  ```javascript  
  // --------------------------------------------------------------------------
  // 1차원 Array 객체에 저장된 데이터 중에 랜덤하게 
  // 하나의 데이터를 복사해서 리턴하는 함수  
  // --------------------------------------------------------------------------
  function getRandomData( arr ){
    // Array 객체의 배열변수의 개수, null 값도 개수에 들어간다.  
    var cnt = arr.length;
    // 랜덤한 인덱스번호 구하기  
    var idx = Math.floor(Math.random()*cnt)
    // 랜덤한 인덱스번호에 해당하는 배열변수의 데이터 리턴하기  
    return arr[idx];
  }

  // --------------------------------------------------------------------------
  // 원본을 훼손하는 랜덤뽑기.
  function getRandomData_with_del( arr ){
    var cnt = arr.length;
    var idx = Math.floor( Math.random()*cnt );
    var randomData = arr[idx];
    arr.splice(idx,1)
    return randomData;
  }
  ```
  > `Math.random()` 은 0~1 사이의 랜덤 소수가 리턴된다.    
  > 0~1 미만 소수 x5 하면,    
  > 0~5 미만 소수이다.  
  >`Math.floor()` 메소드 는 소수부분을 버린다.  

  > 결국 x5 에서는 0~4 까지의 정수가 리턴 된다.  

  > 0~4까지 뽑은 이유는?   
  > array 객체의 인덱스번호를 구한것이다.  
  > 0~4 까지의 인덱스 번호를 주어 랜덤하게 array 안의 배열변수를 인덱스번호로 뽑아서 리턴하는것이다.  

  > ![1차원Array 랜덤 추출](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210916%200954_1%EC%B0%A8%EC%9B%90Array_%EB%9E%9C%EB%8D%A4%EC%B6%94%EC%B6%9C_.png)      

  > 랜덤한 것을 뽑아내려면 랜덤한 인덱스 번호를 구해야 하는 것이다.  

#

- getRandomDataArr

  ```javascript
  // --------------------------------------------------------------------------
  // 1차원 Array 객체에 저장된 데이터 중에 랜덤하게 
  // 원하는 개수의 데이터를 복사해서 또 다른 Array 객체에 담아 리턴하는 함수.  
  // --------------------------------------------------------------------------  

  function getRandomDataArr( arr, cnt ){
    var randomDataArr = [];
    var tmpArr = [];

    while( true ){
      var randomData = getRandomData( arr );
      randomDataArr.push(randomData);
      if( randomDataArr.length==cnt ){ break; }
    }

    return randomDataArr;
  }
  <!-- 위는 중복을 허용하는 반복이다. -->

  <!-- 아래는 중복을 허용하지않는 반복. -->
  function getRandomDataArr( arr, cnt ){
    var randomDataArr = [];
    var tmpArr = [];

    while( true ){
      var randomData = getRandomData( arr );
      var tmp_cnt = 0;
      for( var i=0; i<tmpArr.length; i++){
        if( randomData==tmpArr[i] ){
          tmp_cnt++;
          break;
        }
      }
      if( tmp_cnt>0 ){ continue; }
      randomDataArr.push(randomData);
      <!-- 아래 인덱스번호추가해야한다. -->
      tmpArr.push(randomData);
      if( randomDataArr.length==cnt ){ break; }
    }
    return randomDataArr;
  }

  <!-- 로직상 더 쉬운방법이 있다. -->
  <!-- 원본을 훼손하는 랜덤뽑기사용. -->
  function getRandomDataArr( arr, cnt ){
    if(arr==null || arr.length==0){
      alert("배열변수의 개수가 없습니다.");
      return null;
    }
    if(arr.length<cnt){
      alert("배열변수의 개수보다 랜덤하게 뽑을 개수가 큽니다.");
      return null;
    }
    var randomDataArr = [];
    var arr2 = arr.slice(0); // 0번부터 끝까지 복사.

    for( var i=1; i<=cnt; i++){
      randomDataArr.push( getRandomData_with_del(arr2) )
    }
    return randomDataArr;
  ```
  > 동료 메서드를 활용하여 랜덤한데이터를 뽑아내서 `.push()` 하면 된다.  
  > `while` 에서, `true` 를 주어 무한 반복을 만든 후,  
  > 조건을 주어서 개수 만족할때만 `break` 하도록.   
  > 중복된 데이터는 나오지 않도록 하는것이 문제 제한이였다.  

  > 원본을 훼손하는 랜덤뽑기 `getRandomData_with_del` 를 사용할 때,  
  > 원본훼손을 방지하기 위해,  
  > `slice()` 메서드로 복사해서 진행하면 좋다.  
 

----
### `10:30~`

취업 관련.   

#

- getRandomDataArr2

  ```javascript
  // --------------------------------------------------------------------------
  // 1차원 Array 객체에 저장된 데이터 중에 랜덤하게 
  // min_cnt ~ max_cnt 사이 개수 하나 골라서 그 개수 만큼 데이터를 복사해서 또 다른 Array 객체에 담아 리턴하는 함수.  
  // --------------------------------------------------------------------------
  function getRandomDataArr2( arr, min_cnt, max_cnt ){
    if(arr==null || arr.length==0){
      alert("배열변수의 개수가 없습니다.");
      return null;
    }
    if(arr.length<min_cnt){
      alert("배열변수의 개수보다 랜덤하게 뽑을 개수가 큽니다.");
      return null;
    }
    if(max_cnt<min_cnt){
      alert("뽑을 개수의 범위가 맞지않습니다.");
      return null;
    }
    var randomCntArr = [];

    for ( i=min_cnt; i <= max_cnt; i++ ) {
      randomCntArr.push(i);
    } 	
    var randomCnt = getRandomData( randomCntArr );
    var arr2 = arr.slice(0);
    return getRandomDataArr(arr2, randomCnt);
  }

  ```
  > 뽑히는 개수도 랜덤하게,  
  > 최소 뽑히는개수 ~ 최대 뽑히는 개수,  
  > 사이에서 배열 리턴.  

  ![랜덤추출2](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210916%201103_1%EC%B0%A8%EC%9B%90Array_%EB%9E%9C%EB%8D%A4%EC%B6%94%EC%B6%9C_2.png)  

#

## <게시판 흐름 분석>

`location.replace("/${requestScope.naverPath}boardList.do")` 이 코드는,  
get 방식을 이용한 이동방식이다.    

----
### `11:30~`

`BoardController.java` 에서,   

`"/boardList.do"` 부분,   

주석 추가 및 설명.  

#

`BoardSearchDTO.java` 부분,  
추가 주석,  

```java
// -------------------------------------------------
// [검색 키워드] 저장하는 속성변수 선언
// 현재 [선택된 페이지 번호]를 저장하는 속성변수 선언.
// 한 화면에 보여줄 [행의 개수]를 저장하는 속성변수 선언.
// -------------------------------------------------
private String keyword1;		// 키워드1가 저장될 속성변수
private String keyword2;		// 키워드2가 저장될 속성변수

private String orAnd;			// 두개의 키워드 사이에 들어갈 or 또는 and 가 저장되는 속성변수.    

private int selectPageNo=1;		// 유저가 선택한 페이지번호가 저장되는 속성변수. 반드시 디폴트값이 있어야 DB 연동시 에러가 없다. DB연동하여 처음화면을 보여준다.
private int rowCntPerPage=20;	// 한 화면에 보여줄 행의 개수가 저장되는 속성변수. 반드시 디폴트값이 있어야 DB 연동시 에러가 없다. DB연동하여 처음화면을 보여준다.

// private String[] day;  // 배열로 받을수 있다. 아래코드와 이 코드 방식 두가지로 체크박스르 담을 수 있다.  
private List<String> day; 		// 어제 또는 오늘 또는 그제, 등등이 저장되는 변수. checkbox 입력양식 값이 들어올때는 ArrayList 가 받는다.  
private String sort;			// 등록일 관련 정렬 데이터가 저장되는 속성변수 선언. reg_date desc 또는 reg_date asc 가 저장된다.  
	

```
> `<String>` 제네릭스(Generics),   
> 꺼낼때 형변환 하지 않아도 된다.  

#

(입) 입사시험

자바에서, 알수없는 다량의 데이터를 효율적으로 관리하는 방법론에 논하시오.   

1. `배열 객체`에 저장한다.    
> 총 개수를 안다면 배열쓸 수 있다.    

2. `컬렉션 객체`들 을 쓰는것.
> 컬렉션 객체들 중에 ArrayList 를 주로 사용.  

DB 연동시에 얼마나 들어올지 모르고,  
가변적이므로,  
컬렉션 객체들을 주로 쓴다.  

#

다시,  

`BoardController.java` 로,  

[게시판 목록의 총개수] 얻는 과정으로,  

`int getBoardListCount = this.boardDAO.getBoardListCount( boardSearchDTO );` 에서,  

#

`BoardDAOImpl.java` 로 넘어가고,    

`getBoardListCount()` 메서드의,  

`"com.naver.erp.BoardDAO.getBoardListCount"` 로 인해 매퍼쪽으로 넘어간다.  

#

`mapper_board.xml` 에서,     
`getBoardListCount` 쿼리 실행,          
> 오라클에서는 `==` 이 없다. 주의하기!!! 

> `<sql id="boardWhere">` SQL 태크 활용법 알기.  
> 공통된 조건을 유지보수 편하게 하기위해 수입해서 적용해주는 방식.  

#

위의 과정을 거꾸로,  

매퍼에서 리턴받은 데이터가,    

`BoardDAOImpl.java` 로 넘어가고,      

`BoardController.java` 에,    

`int getBoardListCount = this.boardDAO.getBoardListCount( boardSearchDTO );` 에서,   

총개수를 `getBoardListCount` 변수에 저장한다.  

그 후, 페이지번호 처리로 들어간다.  

![페이지번호](https://github.com/SungWoo0315/study-repository/blob/main/image-save/20210916%201204_%ED%8E%98%EC%9D%B4%EC%A7%80%EB%B2%88%ED%98%B8_%EC%9E%AC%EC%84%A4%EB%AA%85.png)    







----
### `12:30~`








----
### `13:20~`

  - 점심시간.

---
---

## # 오후수업

---
### `14:30~`










---
### `15:30~`









----
### `16:30~`








----
### `17:30~`








----
### `18:30~`
